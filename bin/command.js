// Generated by CoffeeScript 1.8.0
var Docke, args, buildOptions, command, commands, docke, fs, minimist, options, url_parse, usage;

require('colors');

url_parse = require('url').parse;

fs = require('fs');

minimist = require('minimist');

Docke = require('../src/docke');

usage = "\nUsage: " + 'docke'.cyan + " command\n\nCommands:\n  \n  ping      Test the connection to docker\n  ps        List the running dockers and their ip addresses\n  inspect   Show details about a container\n  logs      Attach to the logs of a container\n  run       Start a shell inside a new container\n  exec      Start a shell inside an existing container\n  kill      Delete a container\n";

buildOptions = function(args) {
  var path, result;
  result = {
    host: url_parse(process.env.DOCKER_HOST || 'unix:///var/run/docker.sock'),
    port: process.env.DOCKER_PORT
  };
  if (process.env.DOCKER_TLS_VERIFY !== '' || false && (process.env.DOCKER_CERT_PATH != null)) {
    path = process.env.DOCKER_CERT_PATH;
    result.ca = fs.readFileSync("" + path + "/ca.pem");
    result.cert = fs.readFileSync("" + path + "/cert.pem");
    result.key = fs.readFileSync("" + path + "/key.pem");
    result.https = {
      cert: result.cert,
      key: result.key,
      ca: result.ca
    };
  }
  return result;
};

args = minimist(process.argv.slice(2), {
  "default": {
    'http-addr': '127.0.0.1:8500'
  }
});

if (args._.length === 0) {
  console.error(usage);
  process.exit(1);
}

options = buildOptions(args);

docke = new Docke(options);

commands = {
  ping: function() {
    return docke.ping(function(err, isUp) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      if (isUp) {
        return console.log('docker is up'.green);
      } else {
        return console.error('docker is down'.red);
      }
    });
  },
  ps: function() {
    return docke.ps(function(err, results) {
      var image, name, result, status, _i, _len, _results;
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      if (results.length === 0) {
        console.log("No docker containers");
      }
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        result = results[_i];
        status = result.inspect.State.Running ? result.inspect.NetworkSettings.IPAddress.toString().blue : 'stopped'.red;
        while (status.length < 26) {
          status += ' ';
        }
        name = result.container.Names[0].slice(1);
        image = result.inspect.Config.Image;
        _results.push(console.log("" + status + " " + name + " (" + image + ")"));
      }
      return _results;
    });
  },
  inspect: function() {
    var container;
    if (args._.length !== 2) {
      console.error("docke inspect requires container name");
      console.error(usage);
      process.exit(1);
    }
    container = args._[1];
    return docke.container(container).inspect(function(err, inspect) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      return console.log(inspect);
    });
  },
  logs: function() {
    var container, resize;
    if (args._.length !== 2) {
      console.error("docke logs requires container name");
      console.error(usage);
      process.exit(1);
    }
    container = args._[1];
    resize = function() {
      return docke.container(container).resize(process.stdout.rows, process.stdout.columns, function() {});
    };
    process.stdout.on('resize', resize);
    resize();
    return docke.container(container).logs(function(err, stream) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      return stream.pipe(process.stdout);
    });
  },
  run: function() {
    var image;
    if (args._.length !== 2) {
      console.error("docke run requires image name");
      console.error(usage);
      process.exit(1);
    }
    image = args._[1];
    return docke.image(image).run(process.stdin, process.stdout, process.stderr, function(err, code) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      return process.exit(code);
    });
  },
  exec: function() {
    var container;
    if (args._.length !== 2) {
      console.error("docke exec requires container name");
      console.error(usage);
      process.exit(1);
    }
    container = args._[1];
    return docke.container(container).exec(process.stdin, process.stdout, process.stderr, function(err, code) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      return process.exit(code);
    });
  },
  kill: function() {
    var container;
    if (args._.length !== 2) {
      console.error("docke kill requires container name");
      console.error(usage);
      process.exit(1);
    }
    container = args._[1];
    return docke.container(container).kill(function(err) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      return process.exit(0);
    });
  }
};

command = args._[0];

if (commands[command] == null) {
  console.error("Unknown command " + command.cyan);
  console.error(usage);
  process.exit(1);
}

commands[command]();
