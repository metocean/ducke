// Generated by CoffeeScript 1.8.0
var Docke, args, buildOptions, command, commands, docke, fs, options, parallel, series, url_parse, usage, usage_error;

require('colors');

url_parse = require('url').parse;

fs = require('fs');

Docke = require('../src/docke');

usage = "ðŸ‘¾\n\n  Usage: " + 'docke'.cyan + " command parameters\n\n  Commands:\n  \n    ps        List all running containers\n    logs      Attach to container logs\n    run       Start a shell inside a new container\n    exec      Start a shell inside an existing container\n  \n  Docker management:\n  \n    inspect   Show details about containers\n    kill      Send SIGTERM to running containers\n    stop      Stop containers\n    rm        Delete containers\n";

usage_error = (function(_this) {
  return function(message) {
    console.error();
    console.error(("  " + message).magenta);
    console.error();
    console.error(usage);
    return process.exit(1);
  };
})(this);

series = function(tasks, callback) {
  var next, result;
  tasks = tasks.slice(0);
  next = function(cb) {
    var task;
    if (tasks.length === 0) {
      return cb();
    }
    task = tasks.shift();
    return task(function() {
      return next(cb);
    });
  };
  result = function(cb) {
    return next(cb);
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

parallel = function(tasks, callback) {
  var count, result;
  count = tasks.length;
  result = function(cb) {
    var task, _i, _len, _results;
    if (count === 0) {
      return cb();
    }
    _results = [];
    for (_i = 0, _len = tasks.length; _i < _len; _i++) {
      task = tasks[_i];
      _results.push(task(function() {
        count--;
        if (count === 0) {
          return cb();
        }
      }));
    }
    return _results;
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

buildOptions = function(args) {
  var path, result;
  result = {
    host: url_parse(process.env.DOCKER_HOST || 'unix:///var/run/docker.sock'),
    port: process.env.DOCKER_PORT
  };
  if (process.env.DOCKER_TLS_VERIFY !== '' || false && (process.env.DOCKER_CERT_PATH != null)) {
    path = process.env.DOCKER_CERT_PATH;
    result.ca = fs.readFileSync("" + path + "/ca.pem");
    result.cert = fs.readFileSync("" + path + "/cert.pem");
    result.key = fs.readFileSync("" + path + "/key.pem");
    result.https = {
      cert: result.cert,
      key: result.key,
      ca: result.ca
    };
  }
  return result;
};

args = process.argv.slice(2);

options = buildOptions(args);

docke = new Docke(options);

commands = {
  ps: function() {
    if (args.length !== 0) {
      usage_error('docke ps requires no arguments');
    }
    return docke.ps(function(err, results) {
      var image, name, result, status, _i, _len;
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      if (results.length === 0) {
        console.error();
        console.error('  There are no docker containers on this system'.magenta);
        console.error();
        return;
      }
      console.log();
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        result = results[_i];
        status = result.inspect.State.Running ? result.inspect.NetworkSettings.IPAddress.toString().blue : 'stopped'.red;
        while (status.length < 26) {
          status += ' ';
        }
        name = result.container.Names[0].slice(1);
        image = result.inspect.Config.Image;
        console.log("  " + status + " " + name + " (" + image + ")");
      }
      return console.log();
    });
  },
  inspect: function() {
    var arg, results, tasks, _fn, _i, _len;
    if (args.length === 0) {
      usage_error('docke inspect requires container names');
    }
    tasks = [];
    results = [];
    _fn = function(arg) {
      return tasks.push(function(cb) {
        return docke.container(arg).inspect(function(err, inspect) {
          if (err != null) {
            console.error(err);
            process.exit(1);
          }
          results.push(inspect);
          return cb();
        });
      });
    };
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _fn(arg);
    }
    return series(tasks, function() {
      return console.log(JSON.stringify(results, null, 2));
    });
  },
  logs: function() {
    var arg, _i, _len, _results;
    if (args.length === 0) {
      usage_error('docke logs requires container names');
    }
    _results = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _results.push(docke.container(arg).logs(function(err, stream) {
        if (err != null) {
          console.error(err);
          process.exit(1);
        }
        return stream.pipe(process.stdout);
      }));
    }
    return _results;
  },
  run: function() {
    var fin, image, run;
    if (args.length !== 1) {
      usage_error('docke run requires an image name');
    }
    image = args[0];
    run = function(err, id) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      return docke.container(id).inspect(function(err, inspect) {
        var name;
        if (err != null) {
          console.error(err);
          process.exit(1);
        }
        name = inspect.Name.slice(1);
        image = inspect.Config.Image;
        console.log();
        console.log("  " + 'running'.green + " " + name + " (" + image + ")");
        return console.log();
      });
    };
    fin = function(err, code) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      return process.exit(code);
    };
    return docke.image(image).run(process.stdin, process.stdout, process.stderr, run, fin);
  },
  exec: function() {
    var container;
    if (args.length !== 1) {
      usage_error('docke exec requires a container name');
    }
    container = args[0];
    return docke.container(container).inspect(function(err, inspect) {
      var image, name;
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      name = inspect.Name.slice(1);
      image = inspect.Config.Image;
      console.log();
      console.log("  " + 'exec'.green + " " + name + " (" + image + ")");
      console.log();
      return docke.container(container).exec(process.stdin, process.stdout, process.stderr, function(err, code) {
        if (err != null) {
          console.error(err);
          process.exit(1);
        }
        return process.exit(code);
      });
    });
  },
  stop: function() {
    var arg, tasks, _fn, _i, _len;
    if (args.length === 0) {
      usage_error('docke stop requires container names');
    }
    tasks = [];
    console.log();
    _fn = function(arg) {
      return tasks.push(function(cb) {
        return docke.container(arg).stop(function(err) {
          if (err != null) {
            if (err.statusCode === 404) {
              console.error("  " + arg.red + " is an unknown container");
              return cb();
            }
            if (err.statusCode === 304) {
              console.error("  " + arg.red + " has already been stopped");
              return cb();
            }
            if (err.statusCode === 500) {
              console.error("  could not stop " + arg.red);
              return cb();
            }
            console.error(err);
            console.error(JSON.stringify(err));
            process.exit(1);
          }
          console.log("  " + 'stopped'.green + " " + arg);
          return cb();
        });
      });
    };
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _fn(arg);
    }
    return series(tasks, function() {
      return console.log();
    });
  },
  rm: function() {
    var arg, tasks, _fn, _i, _len;
    if (args.length === 0) {
      usage_error('docke rm requires container names');
    }
    tasks = [];
    console.log();
    _fn = function(arg) {
      return tasks.push(function(cb) {
        return docke.container(arg).rm(function(err) {
          if (err != null) {
            if (err.statusCode === 404) {
              console.error("  " + arg.red + " is an unknown container");
              return cb();
            }
            if (err.statusCode === 500) {
              console.error("  could not delete " + arg.red);
              return cb();
            }
            console.error(err);
            console.error(JSON.stringify(err));
            process.exit(1);
          }
          console.log("  " + 'deleted'.green + " " + arg);
          return cb();
        });
      });
    };
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _fn(arg);
    }
    return series(tasks, function() {
      return console.log();
    });
  },
  kill: function() {
    var arg, tasks, _fn, _i, _len;
    if (args.length === 0) {
      usage_error('docke kill requires container names');
    }
    tasks = [];
    console.log();
    _fn = function(arg) {
      return tasks.push(function(cb) {
        return docke.container(arg).kill(function(err) {
          if (err != null) {
            if (err.statusCode === 404) {
              console.error("  " + arg.red + " is an unknown container");
              return cb();
            }
            if (err.statusCode === 500) {
              console.error("  could not send SIGTERM to " + arg.red);
              return cb();
            }
            console.error(err);
            console.error(JSON.stringify(err));
            process.exit(1);
          }
          console.log("  " + 'killed'.green + " " + arg);
          return cb();
        });
      });
    };
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _fn(arg);
    }
    return series(tasks, function() {
      return console.log();
    });
  }
};

if (args.length === 0) {
  console.error(usage);
  docke.ping(function(err, isUp) {
    if ((err != null) || !isUp) {
      console.error();
      console.error('  docker is down'.red);
      console.error();
      return process.exit(1);
    } else {
      console.error();
      console.error('  docker is up with'.green);
      return docke.ps(function(err, results) {
        var ess, running, stopped;
        if ((err != null) || results.length === 0) {
          console.error();
          console.error('  There are no docker containers on this system'.magenta);
          console.error();
        } else {
          ess = function(num) {
            if (num === 1) {
              return '';
            } else {
              return 's';
            }
          };
          running = results.filter(function(d) {
            return d.inspect.State.Running;
          }).length;
          stopped = running - results.length;
          console.error();
          console.error("    " + (running.toString().green) + " running container" + (ess(running)));
          console.error("    " + (stopped.toString().red) + " stopped container" + (ess(stopped)));
          console.error();
        }
        return process.exit(1);
      });
    }
  });
} else {
  command = args[0];
  args.shift();
  if (commands[command] == null) {
    usage_error("" + command + " is not a known docker command");
  }
  commands[command]();
}
