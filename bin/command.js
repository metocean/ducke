// Generated by CoffeeScript 1.8.0
var Docke, args, buildOptions, command, commands, docke, fs, options, parallel, series, url_parse, usage;

require('colors');

url_parse = require('url').parse;

fs = require('fs');

Docke = require('../src/docke');

usage = "\nUsage: " + 'docke'.cyan + " command\n\nCommands:\n  \n  ping      Test the connection to docker\n  ps        List the running dockers and their ip addresses\n  inspect   Show details about containers\n  logs      Attach to logs of containers\n  run       Start a shell inside a new container\n  exec      Start a shell inside an existing container\n  kill      Send SIGTERM to running containers\n  stop      Stop containers\n  rm        Delete containers\n";

series = function(tasks, callback) {
  var next, result;
  tasks = tasks.slice(0);
  next = function(cb) {
    var task;
    if (tasks.length === 0) {
      return cb();
    }
    task = tasks.shift();
    return task(function() {
      return next(cb);
    });
  };
  result = function(cb) {
    return next(cb);
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

parallel = function(tasks, callback) {
  var count, result;
  count = tasks.length;
  result = function(cb) {
    var task, _i, _len, _results;
    if (count === 0) {
      return cb();
    }
    _results = [];
    for (_i = 0, _len = tasks.length; _i < _len; _i++) {
      task = tasks[_i];
      _results.push(task(function() {
        count--;
        if (count === 0) {
          return cb();
        }
      }));
    }
    return _results;
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

buildOptions = function(args) {
  var path, result;
  result = {
    host: url_parse(process.env.DOCKER_HOST || 'unix:///var/run/docker.sock'),
    port: process.env.DOCKER_PORT
  };
  if (process.env.DOCKER_TLS_VERIFY !== '' || false && (process.env.DOCKER_CERT_PATH != null)) {
    path = process.env.DOCKER_CERT_PATH;
    result.ca = fs.readFileSync("" + path + "/ca.pem");
    result.cert = fs.readFileSync("" + path + "/cert.pem");
    result.key = fs.readFileSync("" + path + "/key.pem");
    result.https = {
      cert: result.cert,
      key: result.key,
      ca: result.ca
    };
  }
  return result;
};

args = process.argv.slice(2);

if (args.length === 0) {
  console.error(usage);
  process.exit(1);
}

options = buildOptions(args);

docke = new Docke(options);

commands = {
  ping: function() {
    if (args.length !== 0) {
      console.error("docke ping requires no arguments");
      console.error(usage);
      process.exit(1);
    }
    return docke.ping(function(err, isUp) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      if (isUp) {
        console.log();
        console.log('  docker is up'.green);
        return console.log();
      } else {
        console.error();
        console.error('  docker is down'.red);
        return console.error();
      }
    });
  },
  ps: function() {
    if (args.length !== 0) {
      console.error("docke ps requires no arguments");
      console.error(usage);
      process.exit(1);
    }
    return docke.ps(function(err, results) {
      var image, name, result, status, _i, _len;
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      if (results.length === 0) {
        console.error();
        console.error('  There are no docker containers on this system'.magenta);
        console.error();
        return;
      }
      console.log();
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        result = results[_i];
        status = result.inspect.State.Running ? result.inspect.NetworkSettings.IPAddress.toString().blue : 'stopped'.red;
        while (status.length < 26) {
          status += ' ';
        }
        name = result.container.Names[0].slice(1);
        image = result.inspect.Config.Image;
        console.log("  " + status + " " + name + " (" + image + ")");
      }
      return console.log();
    });
  },
  inspect: function() {
    var arg, results, tasks, _fn, _i, _len;
    if (args.length === 0) {
      console.error("docke inspect requires container names");
      console.error(usage);
      process.exit(1);
    }
    tasks = [];
    results = [];
    _fn = function(arg) {
      return tasks.push(function(cb) {
        return docke.container(arg).inspect(function(err, inspect) {
          if (err != null) {
            console.error(err);
            process.exit(1);
          }
          results.push(inspect);
          return cb();
        });
      });
    };
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _fn(arg);
    }
    return series(tasks, function() {
      return console.log(JSON.stringify(results, null, 2));
    });
  },
  logs: function() {
    var arg, _i, _len, _results;
    if (args.length === 0) {
      console.error("docke logs requires container names");
      console.error(usage);
      process.exit(1);
    }
    _results = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _results.push(docke.container(arg).logs(function(err, stream) {
        if (err != null) {
          console.error(err);
          process.exit(1);
        }
        return stream.pipe(process.stdout);
      }));
    }
    return _results;
  },
  run: function() {
    var fin, image, run;
    if (args.length !== 1) {
      console.error("docke run requires an image name");
      console.error(usage);
      process.exit(1);
    }
    image = args[0];
    run = function(err, id) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      return docke.container(id).inspect(function(err, inspect) {
        var name;
        if (err != null) {
          console.error(err);
          process.exit(1);
        }
        name = inspect.Name.slice(1);
        image = inspect.Config.Image;
        console.log();
        console.log("  " + 'running'.green + " " + name + " (" + image + ")");
        return console.log();
      });
    };
    fin = function(err, code) {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      return process.exit(code);
    };
    return docke.image(image).run(process.stdin, process.stdout, process.stderr, run, fin);
  },
  exec: function() {
    var container;
    if (args.length !== 1) {
      console.error("docke exec requires a container name");
      console.error(usage);
      process.exit(1);
    }
    container = args[0];
    return docke.container(container).inspect(function(err, inspect) {
      var image, name;
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      name = inspect.Name.slice(1);
      image = inspect.Config.Image;
      console.log();
      console.log("  " + 'exec'.green + " " + name + " (" + image + ")");
      console.log();
      return docke.container(container).exec(process.stdin, process.stdout, process.stderr, function(err, code) {
        if (err != null) {
          console.error(err);
          process.exit(1);
        }
        return process.exit(code);
      });
    });
  },
  stop: function() {
    var arg, tasks, _fn, _i, _len;
    if (args.length === 0) {
      console.error("docke stop requires container names");
      console.error(usage);
      process.exit(1);
    }
    tasks = [];
    console.log();
    _fn = function(arg) {
      return tasks.push(function(cb) {
        return docke.container(arg).stop(function(err) {
          if (err != null) {
            if (err.statusCode === 404) {
              console.error("  " + arg.red + " is an unknown container");
              return cb();
            }
            if (err.statusCode === 304) {
              console.error("  " + arg.red + " has already been stopped");
              return cb();
            }
            if (err.statusCode === 500) {
              console.error("  could not stop " + arg.red);
              return cb();
            }
            console.error(err);
            console.error(JSON.stringify(err));
            process.exit(1);
          }
          console.log("  " + 'stopped'.green + " " + arg);
          return cb();
        });
      });
    };
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _fn(arg);
    }
    return series(tasks, function() {
      return console.log();
    });
  },
  rm: function() {
    var arg, tasks, _fn, _i, _len;
    if (args.length === 0) {
      console.error("docke rm requires container names");
      console.error(usage);
      process.exit(1);
    }
    tasks = [];
    console.log();
    _fn = function(arg) {
      return tasks.push(function(cb) {
        return docke.container(arg).rm(function(err) {
          if (err != null) {
            if (err.statusCode === 404) {
              console.error("  " + arg.red + " is an unknown container");
              return cb();
            }
            if (err.statusCode === 500) {
              console.error("  could not delete " + arg.red);
              return cb();
            }
            console.error(err);
            console.error(JSON.stringify(err));
            process.exit(1);
          }
          console.log("  " + 'deleted'.green + " " + arg);
          return cb();
        });
      });
    };
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _fn(arg);
    }
    return series(tasks, function() {
      return console.log();
    });
  },
  kill: function() {
    var arg, tasks, _fn, _i, _len;
    if (args.length === 0) {
      console.error("docke kill requires container names");
      console.error(usage);
      process.exit(1);
    }
    tasks = [];
    console.log();
    _fn = function(arg) {
      return tasks.push(function(cb) {
        return docke.container(arg).kill(function(err) {
          if (err != null) {
            if (err.statusCode === 404) {
              console.error("  " + arg.red + " is an unknown container");
              return cb();
            }
            if (err.statusCode === 500) {
              console.error("  could not send SIGTERM to " + arg.red);
              return cb();
            }
            console.error(err);
            console.error(JSON.stringify(err));
            process.exit(1);
          }
          console.log("  " + 'killed'.green + " " + arg);
          return cb();
        });
      });
    };
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _fn(arg);
    }
    return series(tasks, function() {
      return console.log();
    });
  }
};

command = args[0];

args.shift();

if (commands[command] == null) {
  console.error("Unknown command " + command.cyan);
  console.error(usage);
  process.exit(1);
}

commands[command]();
