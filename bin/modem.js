// Generated by CoffeeScript 1.8.0
var HttpDuplex, Modem, debug, fs, http, querystring, resolve_path, stream, url, util,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

querystring = require('querystring');

http = require('follow-redirects');

fs = require('fs');

resolve_path = require('path').resolve;

url = require('url');

stream = require('readable-stream');

HttpDuplex = require('./httpduplex');

util = require('util');

debug = require('debug')('modem');

module.exports = Modem = (function() {
  function Modem(options) {
    this.demuxStream = __bind(this.demuxStream, this);
    this._dial = __bind(this._dial, this);
    this._buildParams = __bind(this._buildParams, this);
    this._buildHeaders = __bind(this._buildHeaders, this);
    this.postFile = __bind(this.postFile, this);
    this.post = __bind(this.post, this);
    this.get = __bind(this.get, this);
    var host;
    this._options = {
      https: options.https
    };
    host = options.host;
    if (typeof host === 'string') {
      host = url.parse(host);
    }
    if (options.host.protocol === 'unix:') {
      this.socketPath = config.host.path;
    } else {
      this.host = host;
      if (this.host.protocol === 'tcp:') {
        this.host.protocol = this._options.https ? 'https:' : 'http:';
      }
      if (this.host.port == null) {
        this.host.port = options.port || 2376;
      }
    }
    this.version = options.version;
    this.timeout = options.timeout;
  }

  Modem.prototype.get = function(options, callback) {
    if (typeof options === 'string') {
      options = {
        path: options
      };
    }
    options.method = 'GET';
    return this._dial(options, callback);
  };

  Modem.prototype.post = function(options, content, callback) {
    options.body = JSON.stringify(content);
    options.method = 'POST';
    options.contentType = 'application/json';
    return this._dial(options, callback);
  };

  Modem.prototype.postFile = function(options, file, callback) {
    options.method = 'POST';
    if (typeof file === 'string') {
      file = fs.readFileSync(resolve_path(file));
    }
    options.body = file;
    options.contentType = 'application/tar';
    return this._dail(options, callback);
  };

  Modem.prototype._buildHeaders = function(options) {
    var buffer, headers;
    headers = {};
    if (options.authconfig != null) {
      buffer = new Buffer(JSON.stringify(options.authconfig));
      headers['X-Registry-Auth'] = buffer.toString('base64');
    }
    if (options.contentType != null) {
      headers['Content-Type'] = options.contentType;
    }
    if (typeof options.body === 'string') {
      headers['Content-Length'] = Buffer.byteLength(options.body);
    } else if (Buffer.isBuffer(options.body)) {
      headers['Content-Length'] = options.body.length;
    }
    return headers;
  };

  Modem.prototype._buildParams = function(headers, path, method) {
    var params;
    if (this.version != null) {
      path = "/" + this.version + options.path;
    }
    params = {
      headers: headers,
      path: path,
      method: method
    };
    if (this.socketPath) {
      params.socketPath = this.socketPath;
    } else {
      params.protocol = this.host.protocol;
      params.hostname = this.host.hostname;
      params.port = this.host.port;
    }
    if (this._options.https != null) {
      params.key = this._options.https.key;
      params.cert = this._options.https.cert;
      params.ca = this._options.https.ca;
    }
    return params;
  };

  Modem.prototype._dial = function(options, callback) {
    var headers, params, req;
    headers = this._buildHeaders(options);
    params = this._buildParams(headers, options.path, options.method);
    req = http[params.protocol.slice(0, -1)].request(params, function() {});
    debug('Sending: %s', util.inspect(params, {
      showHidden: true,
      depth: null
    }));
    if (this.timeout) {
      req.on('socket', (function(_this) {
        return function(socket) {
          socket.setTimeout(_this.timeout);
          return socket.on('timeout', function() {
            return req.abort();
          });
        };
      })(this));
    }
    req.on('response', (function(_this) {
      return function(res) {
        var content, msg;
        if (res.statusCode < 200 || res.statusCode >= 300) {
          msg = new Error("" + res.statusCode + " - " + json);
          msg.statusCode = res.statusCode;
          msg.json = json;
          return callback(msg, null);
        }
        if (options.openStdin === true) {
          return callback(null, new HttpDuplex(req, res));
        }
        if (options.isStream === true) {
          return callback(null, res);
        }
        content = '';
        res.on('data', function(data) {
          return content += data;
        });
        return res.on('end', function() {
          var e, json;
          debug('Received: %s', content);
          json = void 0;
          try {
            json = JSON.parse(content);
          } catch (_error) {
            e = _error;
            json = content;
          }
          return callback(null, json);
        });
      };
    })(this));
    req.on('error', (function(_this) {
      return function(error) {
        return callback(error, null);
      };
    })(this));
    if (options.openStdin) {
      return;
    }
    if (options.body == null) {
      return req.end();
    }
    if (typeof options.body === 'string' || Buffer.isBuffer(options.body)) {
      req.write(options.body);
      req.end();
    }
    return options.body.pipe(req);
  };

  Modem.prototype.demuxStream = function(stream, stdout, stderr) {
    return stream.on('readable', function() {
      var header, payload, type, _results;
      header = header || stream.read(8);
      _results = [];
      while (header !== null) {
        type = header.readUInt8(0);
        payload = stream.read(header.readUInt32BE(4));
        if (payload === null) {
          break;
        }
        if (type === 2) {
          stderr.write(payload);
        } else {
          stdout.write(payload);
        }
        _results.push(header = stream.read(8));
      }
      return _results;
    });
  };

  return Modem;

})();
