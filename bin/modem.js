// Generated by CoffeeScript 1.8.0
var HttpDuplex, Modem, debug, fs, http, querystring, resolve_path, stream, url, util,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

querystring = require('querystring');

http = require('follow-redirects');

fs = require('fs');

resolve_path = require('path').resolve;

url = require('url');

stream = require('readable-stream');

HttpDuplex = require('./httpduplex');

util = require('util');

debug = require('debug')('modem');

module.exports = Modem = (function() {
  function Modem(options) {
    this.demuxStream = __bind(this.demuxStream, this);
    this.buildRequest = __bind(this.buildRequest, this);
    this.dial = __bind(this.dial, this);
    this.post = __bind(this.post, this);
    this.get = __bind(this.get, this);
    var host;
    this._options = {
      https: options.https
    };
    host = options.host;
    if (typeof host === 'string') {
      host = url.parse(host);
    }
    if (options.host.protocol === 'unix:') {
      this.socketPath = config.host.path;
    } else {
      this.host = host;
      if (this.host.protocol === 'tcp:') {
        this.host.protocol = this._options.https ? 'https:' : 'http:';
      }
      if (this.host.port == null) {
        this.host.port = options.port || 2376;
      }
    }
    this.version = options.version;
    this.timeout = options.timeout;
  }

  Modem.prototype.get = function(options, callback) {
    if (typeof options === 'string') {
      options = {
        path: options
      };
    }
    options.method = 'GET';
    return this.dial(options, callback);
  };

  Modem.prototype.post = function(options, callback) {
    options.method = 'POST';
    return this.dial(options, callback);
  };

  Modem.prototype.dial = function(options, callback) {
    var address, buffer, data, headers, params, path, req;
    headers = {};
    if (options.authconfig) {
      buffer = new Buffer(JSON.stringify(options.authconfig));
      headers['X-Registry-Auth'] = buffer.toString('base64');
    }
    data = void 0;
    if (options.file) {
      if (typeof options.file === 'string') {
        data = fs.readFileSync(resolve_path(options.file));
      } else {
        data = options.file;
      }
      headers['Content-Type'] = 'application/tar';
    } else if (options.body && options.method === 'POST') {
      data = JSON.stringify(options.body);
      headers['Content-Type'] = 'application/json';
    }
    if (typeof data === 'string') {
      headers['Content-Length'] = Buffer.byteLength(data);
    } else if (Buffer.isBuffer(data)) {
      headers['Content-Length'] = data.length;
    }
    params = {
      headers: headers
    };
    path = options.path;
    if (this.version != null) {
      path = "/" + this.version + options.path;
    }
    if (this.socketPath) {
      params.socketPath = this.socketPath;
      params.path = path;
      params.method = options.method;
    } else {
      address = url.format({
        protocol: this.host.protocol,
        hostname: this.host.hostname,
        port: this.host.port
      });
      address = url.resolve(address, path);
      address = url.parse(address);
      params.protocol = address.protocol;
      params.hostname = address.hostname;
      params.port = address.port;
      params.path = address.path;
      params.method = options.method;
    }
    if (this._options.https != null) {
      params.key = this._options.https.key;
      params.cert = this._options.https.cert;
      params.ca = this._options.https.ca;
    }
    req = this.buildRequest(params, options, data, callback);
    if (typeof data === 'string' || Buffer.isBuffer(data)) {
      req.write(data);
    } else {
      if (data) {
        data.pipe(req);
      }
    }
    if (!options.openStdin && (typeof data === 'string' || data === undefined || Buffer.isBuffer(data))) {
      return req.end();
    }
  };

  Modem.prototype.buildRequest = function(params, options, data, callback) {
    var req;
    req = http[params.protocol.slice(0, -1)].request(params, function() {});
    debug('Sending: %s', util.inspect(params, {
      showHidden: true,
      depth: null
    }));
    if (this.timeout) {
      req.on('socket', (function(_this) {
        return function(socket) {
          socket.setTimeout(_this.timeout);
          return socket.on('timeout', function() {
            return req.abort();
          });
        };
      })(this));
    }
    req.on('response', (function(_this) {
      return function(res) {
        var content, msg;
        if (res.statusCode < 200 || res.statusCode >= 300) {
          msg = new Error("" + res.statusCode + " - " + json);
          msg.statusCode = res.statusCode;
          msg.json = json;
          return callback(msg, null);
        }
        if (options.openStdin === true) {
          return callback(null, new HttpDuplex(req, res));
        }
        if (options.isStream === true) {
          return callback(null, res);
        }
        content = '';
        res.on('data', function(data) {
          return content += data;
        });
        return res.on('end', function() {
          var e, json;
          debug('Received: %s', content);
          json = void 0;
          try {
            json = JSON.parse(content);
          } catch (_error) {
            e = _error;
            json = content;
          }
          return callback(null, json);
        });
      };
    })(this));
    req.on('error', (function(_this) {
      return function(error) {
        return callback(error, null);
      };
    })(this));
    return req;
  };

  Modem.prototype.demuxStream = function(stream, stdout, stderr) {
    var header;
    header = null;
    return stream.on('readable', function() {
      var payload, type, _results;
      header = header || stream.read(8);
      _results = [];
      while (header !== null) {
        type = header.readUInt8(0);
        payload = stream.read(header.readUInt32BE(4));
        if (payload === null) {
          break;
        }
        if (type === 2) {
          stderr.write(payload);
        } else {
          stdout.write(payload);
        }
        _results.push(header = stream.read(8));
      }
      return _results;
    });
  };

  return Modem;

})();
