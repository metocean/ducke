// Generated by CoffeeScript 1.8.0
var Docke, Modem, buildOptions, demux, parallel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Modem = require('./modem');

demux = require('./demuxstream');

buildOptions = function(args) {
  var path, result;
  result = {
    host: url_parse(process.env.DOCKER_HOST || 'unix:///var/run/docker.sock'),
    port: process.env.DOCKER_PORT
  };
  if (process.env.DOCKER_TLS_VERIFY !== '' || false && (process.env.DOCKER_CERT_PATH != null)) {
    path = process.env.DOCKER_CERT_PATH;
    result.ca = fs.readFileSync("" + path + "/ca.pem");
    result.cert = fs.readFileSync("" + path + "/cert.pem");
    result.key = fs.readFileSync("" + path + "/key.pem");
    result.https = {
      cert: result.cert,
      key: result.key,
      ca: result.ca
    };
  }
  return result;
};

parallel = function(tasks, callback) {
  var count, result;
  count = tasks.length;
  result = function(cb) {
    var task, _i, _len, _results;
    if (count === 0) {
      return cb();
    }
    _results = [];
    for (_i = 0, _len = tasks.length; _i < _len; _i++) {
      task = tasks[_i];
      _results.push(task(function() {
        count--;
        if (count === 0) {
          return cb();
        }
      }));
    }
    return _results;
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

module.exports = Docke = (function() {
  function Docke(options) {
    this.run = __bind(this.run, this);
    this.startExec = __bind(this.startExec, this);
    this.exec = __bind(this.exec, this);
    this.resize = __bind(this.resize, this);
    this.logs = __bind(this.logs, this);
    this.inspect = __bind(this.inspect, this);
    this.ps = __bind(this.ps, this);
    this.ping = __bind(this.ping, this);
    this._modem = new Modem(options);
  }

  Docke.prototype.ping = function(callback) {
    return this._modem.get('/_ping').result(function(err, result) {
      if (err != null) {
        return callback(err);
      }
      return callback(null, result === 'OK');
    });
  };

  Docke.prototype.ps = function(callback) {
    return this._modem.get('/containers/json').result((function(_this) {
      return function(err, containers) {
        var container, errors, results, tasks, _fn, _i, _len;
        if (err != null) {
          return callback(err);
        }
        results = [];
        errors = [];
        tasks = [];
        _fn = function(container) {
          return tasks.push(function(cb) {
            return _this._modem.get("/containers/" + container.Id + "/json").result(function(err, inspect) {
              if (err != null) {
                errors.push(err);
                return cb();
              }
              results.push({
                container: container,
                inspect: inspect
              });
              return cb();
            });
          });
        };
        for (_i = 0, _len = containers.length; _i < _len; _i++) {
          container = containers[_i];
          _fn(container);
        }
        return parallel(tasks, function() {
          results.sort(function(a, b) {
            a = a.container.Names[0];
            b = b.container.Names[0];
            if (a > b) {
              return 1;
            }
            if (a < b) {
              return -1;
            }
            return 0;
          });
          if (errors.length > 0) {
            return callback(errors, results);
          }
          return callback(null, results);
        });
      };
    })(this));
  };

  Docke.prototype.inspect = function(id, callback) {
    return this._modem.get("/containers/" + id + "/json").result(callback);
  };

  Docke.prototype.logs = function(id, callback) {
    return this._modem.get("/containers/" + id + "/logs?stderr=1&stdout=1&follow=1&tail=10").stream(callback);
  };

  Docke.prototype.resize = function(id, rows, columns, callback) {
    return this._modem.get("/containers/" + id + "/resize?h=" + rows + "&w=" + columns).result((function(_this) {
      return function(err, result) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, result === 'OK');
      };
    })(this));
  };

  Docke.prototype.exec = function(id, cmd, callback) {
    var params;
    params = {
      AttachStdin: true,
      AttachStdout: true,
      AttachStderr: true,
      Tty: true,
      Cmd: cmd.split(' '),
      Container: id
    };
    return this._modem.post("/containers/" + id + "/exec", params).result(callback);
  };

  Docke.prototype.startExec = function(id, callback) {
    var params;
    params = {
      Detach: false,
      Tty: true
    };
    return this._modem.post("/exec/" + id + "/start", params).connect(callback);
  };

  Docke.prototype.run = function(image, callback) {
    var params;
    params = {
      AttachStdin: true,
      AttachStdout: true,
      AttachStderr: true,
      Tty: true,
      OpenStdin: true,
      StdinOnce: false,
      Cmd: ['bash'],
      Image: image
    };
    return this._modem.post('/containers/create', params).result((function(_this) {
      return function(err, container) {
        if (err != null) {
          return callback(err);
        }
        return _this._modem.post("/containers/" + container.Id + "/attach?stream=true&stdin=true&stdout=true&stderr=true", {}).connect(function(err, stream) {
          if (err != null) {
            return callback(err);
          }
          stream.pipe(process.stdout);
          process.stdin.resume();
          process.stdin.setEncoding('utf8');
          process.stdin.setRawMode(true);
          process.stdin.pipe(stream);
          return _this._modem.post("/containers/" + container.Id + "/start", {}).result(function(err) {
            if (err != null) {
              return callback(err);
            }
            return _this._modem.post("/containers/" + container.Id + "/wait", {}).result(function(err, result) {
              if (err != null) {
                return callback(err);
              }
              process.stdin.removeAllListeners();
              process.stdin.resume();
              stream.end();
              return _this._modem["delete"]("/containers/" + container.Id).result(function(err) {
                if (err != null) {
                  return callback(err);
                }
                return callback(null, result.StatusCode);
              });
            });
          });
        });
      };
    })(this));
  };

  return Docke;

})();
