// Generated by CoffeeScript 1.8.0
var Ducke, Modem, demux, parallel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Modem = require('./modem');

demux = require('./demuxstream');

parallel = function(tasks, callback) {
  var count, result;
  count = tasks.length;
  result = function(cb) {
    var task, _i, _len, _results;
    if (count === 0) {
      return cb();
    }
    _results = [];
    for (_i = 0, _len = tasks.length; _i < _len; _i++) {
      task = tasks[_i];
      _results.push(task(function() {
        count--;
        if (count === 0) {
          return cb();
        }
      }));
    }
    return _results;
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

module.exports = Ducke = (function() {
  function Ducke(options) {
    this.image = __bind(this.image, this);
    this.container = __bind(this.container, this);
    this.createContainer = __bind(this.createContainer, this);
    this.ps = __bind(this.ps, this);
    this.ping = __bind(this.ping, this);
    this._modem = new Modem(options);
  }

  Ducke.prototype.ping = function(callback) {
    return this._modem.get('/_ping').result(function(err, result) {
      if (err != null) {
        return callback(err);
      }
      return callback(null, result === 'OK');
    });
  };

  Ducke.prototype.ps = function(callback) {
    return this._modem.get('/containers/json?all=1').result((function(_this) {
      return function(err, containers) {
        var container, errors, results, tasks, _fn, _i, _len;
        if (err != null) {
          return callback(err);
        }
        results = [];
        errors = [];
        tasks = [];
        _fn = function(container) {
          return tasks.push(function(cb) {
            return _this._modem.get("/containers/" + container.Id + "/json").result(function(err, inspect) {
              if (err != null) {
                errors.push(err);
                return cb();
              }
              results.push({
                container: container,
                inspect: inspect
              });
              return cb();
            });
          });
        };
        for (_i = 0, _len = containers.length; _i < _len; _i++) {
          container = containers[_i];
          _fn(container);
        }
        return parallel(tasks, function() {
          results.sort(function(a, b) {
            a = a.container.Names[0];
            b = b.container.Names[0];
            if (a > b) {
              return 1;
            }
            if (a < b) {
              return -1;
            }
            return 0;
          });
          if (errors.length > 0) {
            return callback(errors, results);
          }
          return callback(null, results);
        });
      };
    })(this));
  };

  Ducke.prototype.createContainer = function(params, callback) {
    return this._modem.post('/containers/create', params).result(callback);
  };

  Ducke.prototype.container = function(id) {
    return {
      inspect: (function(_this) {
        return function(callback) {
          return _this._modem.get("/containers/" + id + "/json").result(callback);
        };
      })(this),
      logs: (function(_this) {
        return function(callback) {
          return _this._modem.get("/containers/" + id + "/logs?stderr=1&stdout=1&follow=1&tail=10").stream(callback);
        };
      })(this),
      resize: (function(_this) {
        return function(rows, columns, callback) {
          return _this._modem.get("/containers/" + id + "/resize?h=" + rows + "&w=" + columns).result(function(err, result) {
            if (err != null) {
              return callback(err);
            }
            return callback(null, result === 'OK');
          });
        };
      })(this),
      start: (function(_this) {
        return function(callback) {
          return _this._modem.post("/containers/" + id + "/start", {}).result(callback);
        };
      })(this),
      stop: (function(_this) {
        return function(callback) {
          return _this._modem.post("/containers/" + id + "/stop?t=5", {}).result(callback);
        };
      })(this),
      wait: (function(_this) {
        return function(callback) {
          return _this._modem.post("/containers/" + id + "/wait", {}).result(callback);
        };
      })(this),
      rm: (function(_this) {
        return function(callback) {
          return _this._modem["delete"]("/containers/" + id).result(callback);
        };
      })(this),
      attach: (function(_this) {
        return function(callback) {
          return _this._modem.post("/containers/" + id + "/attach?stream=true&stdin=true&stdout=true&stderr=true", {}).connect(callback);
        };
      })(this),
      kill: (function(_this) {
        return function(callback) {
          return _this._modem.post("/containers/" + id + "/kill?signal=SIGTERM", {}).result(callback);
        };
      })(this),
      exec: (function(_this) {
        return function(stdin, stdout, stderr, callback) {
          var params;
          params = {
            AttachStdin: true,
            AttachStdout: true,
            AttachStderr: true,
            Tty: true,
            Cmd: ['bash']
          };
          return _this._modem.post("/containers/" + id + "/exec", params).result(function(err, exec) {
            if (err != null) {
              return callback(err);
            }
            return _this._modem.post("/exec/" + exec.Id + "/start", {
              Detach: false,
              Tty: true
            }).connect(function(err, stream) {
              var wasRaw;
              if (err != null) {
                return callback(err);
              }
              stream.pipe(stdout);
              wasRaw = process.isRaw;
              stdin.resume();
              stdin.setEncoding('utf8');
              stdin.setRawMode(true);
              stdin.pipe(stream);
              return stream.on('end', function() {
                stdin.removeAllListeners();
                stdin.setRawMode(wasRaw);
                stdin.resume();
                return callback(null, 0);
              });
            });
          });
        };
      })(this)
    };
  };

  Ducke.prototype.image = function(id) {
    return {
      run: (function(_this) {
        return function(stdin, stdout, stderr, run, fin) {
          var params;
          params = {
            AttachStdin: true,
            AttachStdout: true,
            AttachStderr: true,
            Tty: true,
            OpenStdin: true,
            StdinOnce: false,
            Cmd: ['bash'],
            Image: id
          };
          return _this.createContainer(params, function(err, container) {
            if (err != null) {
              return run(err);
            }
            id = container.Id;
            container = _this.container(container.Id);
            return container.attach(function(err, stream) {
              var wasRaw;
              if (err != null) {
                return run(err);
              }
              run(null, id);
              stream.pipe(stdout);
              wasRaw = process.isRaw;
              stdin.resume();
              stdin.setEncoding('utf8');
              stdin.setRawMode(true);
              stdin.pipe(stream);
              return container.start(function(err) {
                var kill;
                if (err != null) {
                  return fin(err);
                }
                kill = function(signal) {
                  stream.unpipe(stdout);
                  stdin.unpipe(stream);
                  stream.end();
                  return container.kill(function() {});
                };
                process.on('SIGTERM', function() {
                  return kill('SIGTERM');
                });
                process.on('SIGINT', function() {
                  return kill('SIGINT');
                });
                process.on('SIGHUP', function() {
                  return kill('SIGHUP');
                });
                process.on('uncaughtException', function(err) {
                  log(err.stack);
                  return process.exit(1);
                });
                return container.wait(function(err, result) {
                  if (err != null) {
                    return fin(err);
                  }
                  return container.rm(function(err) {
                    if (err != null) {
                      return fin(err);
                    }
                    return fin(null, result.StatusCode);
                  });
                });
              });
            });
          });
        };
      })(this)
    };
  };

  return Ducke;

})();
