// Generated by CoffeeScript 1.8.0
var Ducke, Modem, fs, groupimages, parallel, stream, tardir,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Modem = require('ducke-modem').API;

tardir = require('./tardir');

groupimages = require('./groupimages');

stream = require('stream');

fs = require('fs');

parallel = function(tasks, callback) {
  var count, result;
  count = tasks.length;
  result = function(cb) {
    var task, _i, _len, _results;
    if (count === 0) {
      return cb();
    }
    _results = [];
    for (_i = 0, _len = tasks.length; _i < _len; _i++) {
      task = tasks[_i];
      _results.push(task(function() {
        count--;
        if (count === 0) {
          return cb();
        }
      }));
    }
    return _results;
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

module.exports = Ducke = (function() {
  function Ducke(options) {
    this.image = __bind(this.image, this);
    this.build_image = __bind(this.build_image, this);
    this.container = __bind(this.container, this);
    this.createContainer = __bind(this.createContainer, this);
    this.lls = __bind(this.lls, this);
    this.ls = __bind(this.ls, this);
    this.ps = __bind(this.ps, this);
    this.ping = __bind(this.ping, this);
    this.modem = new Modem(options);
  }

  Ducke.prototype.ping = function(callback) {
    return this.modem.get('/_ping').result(function(err, result) {
      if (err != null) {
        return callback(err);
      }
      return callback(null, result === 'OK');
    });
  };

  Ducke.prototype.ps = function(callback) {
    return this.modem.get('/containers/json?all=1').result((function(_this) {
      return function(err, containers) {
        var container, errors, statuses, tasks, _fn, _i, _len;
        if (err != null) {
          return callback(err);
        }
        statuses = [];
        errors = [];
        tasks = [];
        _fn = function(container) {
          return tasks.push(function(cb) {
            return _this.modem.get("/containers/" + container.Id + "/json").result(function(err, inspect) {
              if (err != null) {
                errors.push(err);
                return cb();
              }
              statuses.push({
                container: container,
                inspect: inspect
              });
              return cb();
            });
          });
        };
        for (_i = 0, _len = containers.length; _i < _len; _i++) {
          container = containers[_i];
          _fn(container);
        }
        return parallel(tasks, function() {
          statuses.sort(function(a, b) {
            a = a.container.Names[0];
            b = b.container.Names[0];
            if (a > b) {
              return 1;
            }
            if (a < b) {
              return -1;
            }
            return 0;
          });
          if (errors.length > 0) {
            return callback(errors, statuses);
          }
          return callback(null, statuses);
        });
      };
    })(this));
  };

  Ducke.prototype.ls = function(callback) {
    return this.modem.get('/images/json?all=1').result((function(_this) {
      return function(err, images) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, groupimages(images));
      };
    })(this));
  };

  Ducke.prototype.lls = function(images, callback) {
    var errors, id, results, tasks, _fn, _i, _len;
    errors = [];
    results = {};
    tasks = [];
    _fn = (function(_this) {
      return function(id) {
        return tasks.push(function(cb) {
          return _this.image(id).inspect(function(err, result) {
            if (err != null) {
              errors.push(err);
              return cb();
            }
            results[result.Id] = result;
            return cb();
          });
        });
      };
    })(this);
    for (_i = 0, _len = images.length; _i < _len; _i++) {
      id = images[_i];
      _fn(id);
    }
    return parallel(tasks, function() {
      if (errors.length > 0) {
        return callback(errors, results);
      }
      return callback(null, results);
    });
  };

  Ducke.prototype.createContainer = function(name, params, callback) {
    var url;
    url = '/containers/create';
    if (name != null) {
      url += "?name=" + name;
    }
    return this.modem.post(url, params).result(callback);
  };

  Ducke.prototype.container = function(id) {
    return {
      inspect: (function(_this) {
        return function(callback) {
          _this.modem.get("/containers/" + id + "/json").result(callback);
          return _this.container(id);
        };
      })(this),
      logs: (function(_this) {
        return function(callback) {
          _this.modem.get("/containers/" + id + "/logs?stderr=1&stdout=1&follow=1&tail=10").stream(callback);
          return _this.container(id);
        };
      })(this),
      resize: (function(_this) {
        return function(rows, columns, callback) {
          _this.modem.post("/containers/" + id + "/resize?h=" + rows + "&w=" + columns).result(function(err, result) {
            if (err != null) {
              return callback(err);
            }
            return callback(null, result === 'OK');
          });
          return _this.container(id);
        };
      })(this),
      start: (function(_this) {
        return function(callback) {
          _this.modem.post("/containers/" + id + "/start", {}).result(callback);
          return _this.container(id);
        };
      })(this),
      stop: (function(_this) {
        return function(callback) {
          _this.modem.post("/containers/" + id + "/stop?t=5", {}).result(callback);
          return _this.container(id);
        };
      })(this),
      wait: (function(_this) {
        return function(callback) {
          _this.modem.post("/containers/" + id + "/wait", {}).result(callback);
          return _this.container(id);
        };
      })(this),
      rm: (function(_this) {
        return function(callback) {
          _this.modem["delete"]("/containers/" + id).result(callback);
          return _this.container(id);
        };
      })(this),
      attach: (function(_this) {
        return function(callback) {
          _this.modem.post("/containers/" + id + "/attach?stream=true&stdin=true&stdout=true&stderr=true", {}).connect(callback);
          return _this.container(id);
        };
      })(this),
      kill: (function(_this) {
        return function(callback) {
          _this.modem.post("/containers/" + id + "/kill?signal=SIGTERM", {}).result(callback);
          return _this.container(id);
        };
      })(this),
      exec: (function(_this) {
        return function(cmd, stdin, stdout, stderr, callback) {
          var params;
          params = {
            AttachStdin: true,
            AttachStdout: true,
            AttachStderr: true,
            Tty: true,
            Cmd: cmd
          };
          _this.modem.post("/containers/" + id + "/exec", params).result(function(err, exec) {
            if (err != null) {
              return callback(err);
            }
            return _this.modem.post("/exec/" + exec.Id + "/start", {
              Detach: false,
              Tty: true
            }).connect(function(err, stream) {
              var updatesize, wasRaw;
              if (err != null) {
                return callback(err);
              }
              stream.setEncoding('utf8');
              stream.pipe(stdout);
              wasRaw = process.isRaw;
              stdin.resume();
              stdin.setEncoding('utf8');
              stdin.setRawMode(true);
              stdin.pipe(stream);
              updatesize = function() {
                return _this.modem.post("/exec/" + exec.Id + "/resize?h=" + stdout.rows + "&w=" + stdout.columns, {}).result(function(err, r) {
                  if (err != null) {
                    return console.error(err);
                  }
                });
              };
              stdout.on('resize', updatesize);
              if (stdout.rows != null) {
                updatesize();
              }
              return stream.on('end', function() {
                stdin.removeAllListeners();
                stdin.setRawMode(wasRaw);
                stdin.resume();
                stdout.removeListener('resize', updatesize);
                return callback(null, 0);
              });
            });
          });
          return _this.container(id);
        };
      })(this)
    };
  };

  Ducke.prototype.build_image = function(id, path, usecache, run, callback) {
    if (!fs.existsSync("" + path + "/Dockerfile")) {
      return callback(new Error('No Dockerfile found'));
    }
    return tardir(path, (function(_this) {
      return function(err, archive) {
        var cache;
        if (err != null) {
          return callback(err);
        }
        archive.on('error', callback);
        cache = '';
        if (!usecache) {
          cache = '&nocache=true';
        }
        return _this.modem.postFile("/build?t=" + id + cache, archive).stream(function(err, output) {
          if (err != null) {
            return callback(err);
          }
          output.on('data', function(data) {
            var line, lines, _i, _len, _results;
            data = JSON.parse(data);
            if (data.error != null) {
              return callback(data.error);
            }
            if (data.stream == null) {
              return;
            }
            lines = data.stream.split('\n').filter(function(d) {
              return d !== '';
            });
            _results = [];
            for (_i = 0, _len = lines.length; _i < _len; _i++) {
              line = lines[_i];
              _results.push(run(line));
            }
            return _results;
          });
          return output.on('end', callback);
        });
      };
    })(this));
  };

  Ducke.prototype.image = function(id) {
    return {
      rebuild: (function(_this) {
        return function(path, run, callback) {
          _this.build_image(id, path, false, run, callback);
          return _this.image(id);
        };
      })(this),
      build: (function(_this) {
        return function(path, run, callback) {
          _this.build_image(id, path, true, run, callback);
          return _this.image(id);
        };
      })(this),
      up: (function(_this) {
        return function(name, cmd, callback) {
          var params;
          params = {
            Image: id
          };
          if (cmd.length > 0) {
            params.Cmd = cmd;
          }
          _this.createContainer(name, params, function(err, container) {
            if (err != null) {
              return callback(err);
            }
            id = container.Id;
            container = _this.container(id);
            return container.start(function(err) {
              if (err != null) {
                return callback(err);
              }
              return callback(null, id);
            });
          });
          return _this.image(id);
        };
      })(this),
      inspect: (function(_this) {
        return function(callback) {
          _this.modem.get("/images/" + id + "/json").result(callback);
          return _this.image(id);
        };
      })(this),
      rm: (function(_this) {
        return function(callback) {
          _this.modem["delete"]("/images/" + id).result(callback);
          return _this.image(id);
        };
      })(this),
      run: (function(_this) {
        return function(cmd, stdin, stdout, stderr, run, callback) {
          var params;
          params = {
            AttachStdin: true,
            AttachStdout: true,
            AttachStderr: true,
            Tty: true,
            OpenStdin: true,
            StdinOnce: false,
            Cmd: cmd,
            Image: id
          };
          _this.createContainer(null, params, function(err, container) {
            if (err != null) {
              return run(err);
            }
            id = container.Id;
            container = _this.container(container.Id);
            return container.attach(function(err, stream) {
              var updatesize, wasRaw;
              if (err != null) {
                return run(err);
              }
              run(null, id);
              stream.pipe(stdout);
              wasRaw = process.isRaw;
              stdin.resume();
              stdin.setEncoding('utf8');
              stdin.setRawMode(true);
              stdin.pipe(stream);
              updatesize = function() {
                return container.resize(stdout.rows, stdout.columns, function() {});
              };
              stdout.on('resize', updatesize);
              if (stdout.rows != null) {
                updatesize();
              }
              return container.start(function(err) {
                var kill;
                if (err != null) {
                  return callback(err);
                }
                kill = function(signal) {
                  stream.unpipe(stdout);
                  stdin.unpipe(stream);
                  stream.end();
                  stdout.removeListener('resize', updatesize);
                  return container.kill(function() {});
                };
                process.on('SIGTERM', function() {
                  return kill('SIGTERM');
                });
                process.on('SIGINT', function() {
                  return kill('SIGINT');
                });
                process.on('SIGHUP', function() {
                  return kill('SIGHUP');
                });
                process.on('uncaughtException', function(err) {
                  log(err.stack);
                  return process.exit(1);
                });
                return container.wait(function(err, result) {
                  if (err != null) {
                    return callback(err);
                  }
                  return container.rm(function(err) {
                    if (err != null) {
                      return callback(err);
                    }
                    return callback(null, result.StatusCode);
                  });
                });
              });
            });
          });
          return _this.image(id);
        };
      })(this)
    };
  };

  return Ducke;

})();
